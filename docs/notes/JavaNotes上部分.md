# Java Study Notes 上部分

> by.Xiao_Chen

因内容较多，JavaStudyNotes分为三部分：

- 上部分：初识Java、Java基础语法、面向对象初级、中级和高级部分
- 中部分：枚举、注解、异常、常用类（包装类、String、Math、Object、System、日期类等）、Lambda表达式、集合
- 下部分：泛型、图形界面、线程、IO流、网络编程、正则表达式、反射、数据库编程

笔记仅供参考，查找方法更适合去[JavaAPI文档](https://docs.oracle.com/javase/8/docs/api/)，[中文文档下载（密码:chen）](https://wwxg.lanzoub.com/b02pzrdha) 

一些教程推荐：

- [XiaoChen/JavaStudyNotes](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/JavaNotes.md)

- [菜鸟Java教程](https://www.runoob.com/java/java-tutorial.html)

- [Quick Reference Java 备忘清单](http://bbs.laoleng.vip/reference/docs/java.html)

- [廖雪峰Java教程](https://www.liaoxuefeng.com/wiki/1252599548343744)

- [鱼皮Java学习路线](https://luxian.yupi.icu/#/roadmap/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF)

# 初识Java

## Java语言的特点

1. Java 语言是面向对象的(oop)
2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证
3. Java 语言是跨平台性的[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台] 
4. Java 语言是解释型的
   - 解释性语言：javascript,PHP, java 编译性语言: c/c++
   - 区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行



## JDK和JRE

> JDK 基本介绍 

1. JDK 的全称(Java Development Kit Java 开发工具包) 

   JDK = JRE + java 的开发工具 [java, javac,javadoc,javap 等] 

2. JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。

> JRE 基本介绍 

1. JRE(Java Runtime Environment Java 运行环境) 

   JRE = JVM + Java 的核心类库[类] 

2. 包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可

> JDK、JRE 和 JVM 的包含关系 

1. JDK = JRE +开发工具集（例如 Javac,java 编译工具等）
2. JRE = JVM + Java SE 标准类库（java 核心类库）
3. 如果只想运行开发好的 .class 文件只需要 JRE



## JDK及Eclipse下载地址

- [JDK下载地址](https://www.oracle.com/java/technologies/downloads/)

- [Eclipse下载地址](https://www.eclipse.org/downloads/)



## Java环境搭建

1. 设置-系统信息-高级系统设置-环境变量

2. 增加JAVA_HOME环境变量，指向jdk安装目录
3. 编辑path环境变量，增加%JAVA_HOME%\bin
4. win + r 打开cmd，输入javac/java，如果出现参数信息代表配置成功
5. 输入Java -version可以查看当前环境Java版本



## 第一个Java程序

1. 打开Eclipse

2. 新建一个Java Project：File-New-Project-Java Project

3. 新建一个class类：New-class

   ```java
   public class helloworld {
   	public static void main(String[] args) {
   		System.out.println("Hello,World!");
   	}
   }
   ```



## 标识符

**标识符的命名规则**

1. 由26个英文字母大小写，0-9，或$组成
2. 数字不可以开头

3. 不可以使用关键字和保留字，但能包含关键字和保留字
4. Java中严格区分大小写，长度无限制
5. 标识符不能包含空格

**标识符命名规范**

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰，简称驼峰法] 
4. 常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ
5. 阿里巴巴Java开发手册



# Java基础语法

## Java注释

- 单行注释： `//....`
- 多行注释：`/*....*/`
- 文档注释：`/**....*/`



## 数据类型

### 基本数据类型

#### 整数类型

| 类型名称 | 类型描述 | 字宽 |         取值范围         |         例          |
| :------: | :------: | :--: | :----------------------: | :-----------------: |
|   byte   |  字节型  |  1   |   -2⁷~2⁷-1（-128~127）   |   `byte b = 50;`    |
|  short   |  短整型  |  2   | -2¹⁵~2¹⁵-1(-32768-32767) |  `short s = 500`;   |
|   int    |   整型   |  4   |        -2³¹~2³¹-1        |  `int i = 50000`;   |
|   long   |  长整形  |  8   |        -2⁶³-2⁶³-1        | `long l = 500000L;` |

#### 浮点类型

| 类型名称 |   类型描述   | 字宽 |       取值范围        |          例          |
| :------: | :----------: | :--: | :-------------------: | :------------------: |
|  float   | 单精度浮点数 |  4   |  -3.4* 10³⁸~3.4*10³⁸  |  `float f = 5.5F`;   |
|  double  | 双精度浮点数 |  8   | -1.7* 10³⁰⁸~1.7*10³⁰⁸ | `double d = 123.45;` |

#### 字符类型

- char 字符型
- 字宽：2 
- 例：`char c = '字';`

#### 布尔类型

- boolean 布尔型
- 字宽：1
- 取值范围：true false
- 例：`boolean b = true;`



### 引用数据类型

> 引用数据类型分为类、接口和数组

#### 数组

##### 数组的使用

- **动态初始化**

   - 语法:数据类型 数组名[] = new 数据类型[大小]

   - 先声明数组 

     语法:数据类型 数组名[]; 也可以 数据类型[] 数组名; 

     创建数组 

     语法: 数组名=new 数据类型[大小]; 

- **静态初始化**
  
   - 语法:数据类型 数据名[] = {元素值,元素值...}
   
- **使用细节和注意事项**

   1. 数组是多个相同类型数据的组合，实现对这些数据的统一管理

   2. 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用

   3. 数组创建后，如果没有赋值，有默认值

      int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null

    4. 使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组

    5. 数组的下标是从0开始的

    6. 数组下标必须在指定范围内使用，否则报：下标越界异常

    7. 数组属引用类型，数组型数据是对象(object)

##### 数组赋值机制

- 基本数据类型赋值，这个值就是具体的数据，而且相互不影响
- 数组在默认情况下是引用传递，赋的值是地址

##### 数组拷贝

- [ArrayCopy.java · 小陈/Java Study Notes - Gitee.com](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/ArrayCopy.java)

##### 数组反转

- 要求：把数组的元素内容反转

  arr {11,22,33,44,55,66}   {66, 55,44,33,22,11}

- [通过找规律反转](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/ArrayReverse.java)
- [使用逆序赋值方式](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/ArrayReverse02.java)

##### 数组添加/扩容

- 要求：实现动态的给数组添加元素效果，实现对数组扩容
  1. 原始数组使用静态分配 int[] arr = {1,2,3} 
  2. 增加的元素 4，直接放在数组的最后 arr = {1,2,3,4} 
  3. 用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n
- [ArrayAdd.java · 小陈/Java Study Notes - Gitee.com](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/ArrayAdd.java)

##### 排序

- 介绍：排序是将多个数据，依指定的顺序进行排列的过程

- 内部排序: 指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)

- 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)

- 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

  [BubbleSort.java · 小陈/Java Study Notes - Gitee.com](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/BubbleSort.java)

##### 查找

- 顺序查找

  有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：从键盘中任意输入一个名称，判断数列中是否 

  包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值

  [SeqSearch.java · 小陈/Java Study Notes - Gitee.com](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/SeqSearch.java)

##### 二维数组

- 使用方式

  1. 动态初始化

     - 语法: 类型[] [] 数组名=new 类型[大小] [大小]

     - 先声明：类型 数组名[] []; 

       再定义(开辟空间) 数组名 = new 类型[大小] [大小] 

       赋值(有默认值，比如 int 类型的就是 0)

  2. 静态初始化

     - 定义 类型 数组名[][] = {{值 1,值 2..},{值 1,值 2..},{值 1,值 2..}}

- 案例：杨辉三角

  [YangHui.java · 小陈/Java Study Notes - 码云 - 开源中国 (gitee.com)](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/YangHui.java)

- 使用细节和注意事项

  1. 一维数组的声明方式有: int[] x 或者 int x[] 
  2. 二维数组的声明方式有: int[] []  y 或者 int[]  y[] 或者 int  y[] []
  3. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同

## 常量和变量

### 常量

> 程序在运行过程中，其值不能被修改的量

- 整形常量，实型常量，字符常量，布尔常量，字符串常量，自定义常量

### 变量

> 程序在运行过程中，其值可以被修改的量

- 声明变量
  - 数据类型 变量名;
  - 数据类型 变量名1,变量名2,变量名3;

- 初始化变量

  - 变量名 = 数值;

  - `int age;`
    `age = 20;`

- 变量声明和赋值写在同一条语句中
  - 数据类型 变量名 = 数值;  <变量三要素>
  - `int age = 20;`

- 细节
  - 变量需先声明后使用，即有顺序
  - 该区域的数据/值可以在**同一类型**范围内不断变化
  - 变量在同一作用域内不能重名



## 数据类型转换

### 自动类型转换

- 代码不需要进行特殊处理，自动完成
- 低精度数值自动转为高精度数值
- 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算
- byte，short，char在计算时首先会转化为int型
- boolean不参与转换
- 自动提升原则:表达式结果的类型自动提升为操作数中最大的类型



### 强制类型转换

- 将容量大的数据类型转换为容量小的数据类型
- 可能造成精度降低或溢出
- 变量名 = (转换后类型)转换前数据
- `int i = 100;`
  `i = (byte)100;`



## 运算符

### 算术运算符

> 前四为单目运算符，后四为双目运算符

| 运算符 |    名称    |        功能        |
| :----: | :--------: | :----------------: |
|   +    |    正号    |  表示数字本身的值  |
|   -    |    负号    | 表示一个数相反的值 |
|   ++   | 自增运算符 |  表示将变量的值+1  |
|   --   | 自减运算符 |  表示将变量的值-1  |
|   +    | 加法运算符 |   表示两个数相加   |
|   -    | 减法运算符 |   表示两个数相减   |
|   *    | 乘法运算符 |   表示两个数相乘   |
|   /    | 除法运算符 |   表示两个数相除   |
|   %    | 取模运算符 |  得到两个数的余数  |

- 细节

    - 前++和后++都等价于i=i+1
    - 前++：++i先自增后赋值`int j = ++i;`结果为i=j
    - 后++：i++先赋值后自增`int j = i++;`结果为j=i，i=i+1
    - +号当左右两边为字符串时做拼接运算
    - 整数之间相除只保留整数部分，舍弃小数部分 `int x = 10/3;`结果为3
    - 对于一个数**取模**时，可以等价于 **a % b = a - a / b * b**
    - **a % b** 当a是**小数**时，公式 **= a - (int)a / b * b** 



### 关系运算符

> 大于> 小于< 大于等于>= 小于等于<= 等于== 不等于!=

- 关系运算符结果都为boolean型，即true or false
- 关系运算符组成的表达式称为关系表达式 a > b
- “==”不能写成“=”



### 逻辑运算符

> 用于连接多个条件（多个关系表达式），最终结果是boolean值

#### 逻辑非

> 逻辑非！

1. 如果条件本身成立，结果为 false，否则为 true

2. 对操作数的值取反

3. 举例：
   ```java
    //! 操作是取反 T->F , F -> T 
    System.out.println(60 > 20); //T
    System.out.println(!(60 > 20)); //F
   ```

#### 逻辑与、短路与

> 逻辑与& 短路与&&

1. 相同点：两个条件都为 true，结果为 true,否则 false

2. 不同点：
   - &&短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高 
   - & 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低

3. 举例：

   ```java
   int a = 4; 
   int b = 9; 
   if(a < 1 & ++b < 50) { 
       System.out.println("ok300"); 
   }
   System.out.println("a=" + a + " b=" + b);// 4 10
   //对于&&短路与而言，如果第一个条件为 false ,后面的条件不再判断 即a=4,b=9
   //对于&逻辑与而言，如果第一个条件为 false ,后面的条件仍然会判断 即a=4,b=10
   ```
   

#### 逻辑或、短路或

> 逻辑或| 短路或||

1. 相同点：两个条件中只要有一个成立，结果为 true,否则为 false

2. 不同点：

   - || 短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高 

   - | 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低

3. 举例：

   ````java
   int a = 4; 
   int b = 9; 
   if( a > 1 || ++b > 4) {
       System.out.println("ok300"); 
   }
   System.out.println("a=" + a + " b=" + b); //4 10
   //|| 短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true 即a=4,b=9
   //| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低 即a=4,b=10

#### 逻辑异或

> 逻辑异^

- a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false
- 举例：

   ````java
   boolean b = (10 > 1) ^ ( 3 > 5); 
   System.out.println("b=" + b);//T
   ````



### 位运算符

#### 原码、反码、补码

1. 二进制的最高位是符号位:**0**表示**正数**,**1**表示**负数**
2. **正数**的原码，反码，补码都一样(**三码合一**)
3. 负数的反码：它的原码**符号位不变**，其它位取反(0->1 1->0)
4. 负数的补码：它的**反码+1**，负数的反码=负数的补码-1
5. 0的反码，补码都是0
6. java没有无符号数，换言之，java中的数都是有符号的
7. 在计算机运算的时候，都是以**补码的方式来运算**的
8. 当我们看运算结果的时候，要看他的**原码**

#### 位运算符

> 按位与& 按位或| 按位异或^ 按位取反~ 算术右移>> 算术左移<< 逻辑右移>>>

1. 按位与&：两位全为1，结果为1，否则为0

2. 按位或|：两位有一个为1，结果为1，否则为0

3. 按位异或^：两位一个为0一个为1，结果为1，否则为0

4. 按位取反~ ：0变成1,1变成0（0->11->0）

5. 按位右移>>：将二进制右移指定位数 a >> b 本质 a / 2ᵇ

6. 按位左移<<：将二进制左移指定位数 a << b 本质 a * 2ᵇ

7. 不带符号的按位右移>>>：将二进制右移指定位数，左面的空位一律添0



### 赋值运算符

| 运算符 |     名称     |        功能         |
| :----: | :----------: | :-----------------: |
|   =    |     赋值     | a=b表示将b的值赋给a |
|   +=   |    加赋值    |   a+=b等价于a=a+b   |
|   -=   |    减赋值    |   a-=b等价于a=a-b   |
|   *=   |    乘赋值    |  a*=b等价于a=a *b   |
|   /=   |    除赋值    |   a/=b等价于a=a/b   |
|   %=   |   取模赋值   |   a%=b等价于a=a%b   |
|  <<=   | 算术左移赋值 |  a<<=b等价于a=a<<b  |
|  >>=   | 算术右移赋值 |  a>>=b等价于a=a>>b  |
|  >>>=  | 逻辑右移赋值 | a>>>=b等价于a=a>>>b |
|   &=   |   位与赋值   |   a&=b等价于a=a&b   |
|  \|=   |   位或赋值   |  a\|=b等价于a=a\|b  |
|   ^=   |  位异或赋值  |   a^=b等价于a=a^b   |

````java
//复合赋值运算符会进行类型转换 
byte b = 3; b += 2; //等价 b = (byte)(b + 2); 
b++; //等价 b = (byte)(b+1);
````



### 三元运算符

- 条件表达式 ? 表达式 1: 表达式 2;

- 运算规则： 
  
  - 如果条件表达式为 true，运算后的结果是表达式 1； 
  - 如果条件表达式为 false，运算后的结果是表达式 2；
  
    ```java
  int a = 10; 
  int b = 99;
  int result = a > b ? a++ : b--; // a > b 为 false 先返回结果b（result = 99）然后计算a++ b--
  System.out.println("result=" + result); //result=99
  System.out.println("a=" + a); //a=11
  System.out.println("b=" + b);//b=100
  
- 注意：

  - 表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换) 
  
    ````java
    //表达式 1 和表达式 2 要为可以赋给接收变量的类型 (或可以自动转换/或者强制转换) 
    int a = 3; int b = 8; 
    int c = a > b ? (int)1.1 : (int)3.4;//可以的 
    double d = a > b ? a : b + 3;//可以的，满足 int -> double
    ````
    
  - 三元运算符可以转成 if--else 语句
    
    ````java
    //int res = a > b ? a++ : --b; 可以转换为
    if ( a > b) res = a++; 
    else res = --b;
    ````



### 运算符优先级

| 运算符                                                     | 结合性   |
| ---------------------------------------------------------- | -------- |
| [] . () (方法调用)                                         | 从左向右 |
| ! ~ ++ -- + (一元运算) - (一元运算) ( ) (强制类型转换) new | 从右向左 |
| * / %                                                      | 从左向右 |
| + -                                                        | 从左向右 |
| << >> >>>                                                  | 从左向右 |
| > <= > >= instanceof                                       | 从左向右 |
| = !=                                                       | 从左向右 |
| &                                                          | 从左向右 |
| ^                                                          | 从左向右 |
| \|                                                         | 从左向右 |
| &&                                                         | 从左向右 |
| \|\|                                                       | 从左向右 |
| ?:                                                         | 从右向左 |
| = += -= *= /= %= &= \|= ^= <<= >>= >>>=                    | 从右向左 |



## 程序控制结构

### 分支

#### 顺序控制

- 程序从上到下逐行地执行，中间没有任何判断和跳转

#### 分支控制

##### 单分支

```java
if(条件表达式1){
      执行代码块1;
}
else{
      执行代码块2;
}
```

##### 多分支

```java
if(条件表达式1){
      执行代码块1;
}
else if(条件表达式2){
      执行代码块2;
}
  ... ...
else{
      执行代码块n;
}
```

<img src="https://pb.nichi.co/tag-hospital-crisp" alt="img" style="zoom: 50%;" /> #运行模型如图所示

##### 嵌套分支

```java
if(){
    if(){
        //if-else...
    }else{
        //if-else...
    }
}else{
    
}
```

**问题举例**

```java
import java.util.Scanner;
public class piao {
	public static void main(String[] args) {
		/*出票系统:根据淡旺季的月份和年龄，打印票价
		4-10旺季:
		成人(18-60):60 儿童(<18):半价 老人(>60):1/3
		淡季:
		成人:40其他:20 */
		Scanner myScanner = new Scanner(System.in);
		System.out.println("请输入月份");
		int month = myScanner.nextInt();
		System.out.println("请输入年龄");
		int age = myScanner.nextInt();
		if(month >0 && month < 13 && age > 0) {
			if(month >= 4 && month <= 10) {
				if(age < 18) {
					System.out.println("您的票价为30");
				}else if(age >= 18 && age <= 60) {
					System.out.println("您的票价为60");
				}else if(age > 60) {
					System.out.println("您的票价为20");
				}
			}else {
				if(age >= 18 && age <= 60) {
					System.out.println("您的票价为40");
				}else if (age < 18 || age > 60) {
					System.out.println("您的票价为20");
				}
			}
		}else {
			System.out.println("您输入的年龄或月份有误");
		}
	}
}
```



#### switch多重选择

- **基本语法**

  ```java
  switch(表达式){
      case 常量1:  //当...
          语句块1;
          break;
      case 常量2:
          语句块2;
          break;
      ...
      case 常量n:
          语句块n;
          break;
      default:
          default语句块;
          break;
  } 
  ```
  
- **流程图**

  <img src="https://pb.nichi.co/axis-happy-father" style="zoom:50%;" /> 

- **细节**
  1. 表达式数据类型，应和case 后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是int
  2. switch(表达式)中表达式的返回值必须是:(byte,short,int,char,enum[枚举],String)
  3. case子句中的值必须是常量，而不能是变量
  4. default子句是可选的，当没有匹配的case时，执行default
  5. break语句用来在执行完一个case分支后使程序跳出switch语句块;如果没有写break，程序会顺序执行到switch结尾，除非遇到break;

### 循环

#### for

- **基本语法**

  ```java
  for(循环变量初始化;循环条件;循环变量迭代){
      循环操作(可以多条语句);
  }
  ```

- **流程图**

  <img src="https://pb.nichi.co/intact-frequent-lava" style="zoom:38%;" /> 

- **注意事项和细节说明**
  1. 循环条件是返回一个布尔值的表达式
  2. for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略
  3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开
  4. for(;;)代表无限循环

- **代码举例** 

  > 打印1~100之间所有是 9 的倍数的整数，统计个数及总和[**化繁为简,先死后活**]

  [Gitee直达链接]([ForExercise.java · 小陈/Java Study Notes - 码云 - 开源中国 (gitee.com)](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/ForExercise.java))

#### while

- **基本语法**

  ```java
  循环变量初始化;
  while(循环条件){
      循环体(语句);
      循环变量迭代;
  }//while也有四要素，只是四要素和for放置的位置不同
  ```

- **流程图**

  <img src="https://pb.nichi.co/short-leaf-myself" style="zoom:40%;" /> 

- **注意事项和细节说明**
  - 循环条件是返回一个布尔值的表达式 
  - while 循环是先判断再执行语句



#### do-while

- **基本语法**

  ```java
  循环变量初始化; 
  do{ 
      循环体(语句); //先执行，再判断，也就是说，一定会至少执行一次
      循环变量迭代; 
  }while(循环条件);//最后有一个分号; 
  //do while是关键字
  //也有循环四要素, 只是位置不一样
  //while和do-while 区别举例: 要账
  ```

- **流程图**

  <img src="https://pb.nichi.co/among-decrease-chunk" style="zoom:60%;" />  

- **注意事项和细节说明**
  - 循环条件是返回一个布尔值的表达式
  - do-while 循环是先执行，再判断，因此它至少执行一次

#### 多重循环

1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中for ,while ,do…while 均可以作为外层循环和内层循环[建议一般使用两层，最多不要超过 3 层, 否则，代码的可读性很差]
2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环
3. 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次



- 打印金字塔

  [Gitee直达链接](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/Stars.java)



### 跳转控制语句

#### break

> 结束循环

- 基本语法

  ```java 
  { 
      ……
      break; 
      …… 
  } 
  ```
  
- 流程图

  <img src="https://pb.nichi.co/organ-private-net" style="zoom: 40%;" /> 



#### continue

> 跳转到下一次循环

- 基本语法

  ```java 
  {
      ……
      continue; 
      …… 
  } 
  ```

- 流程图

  <img src="https://pb.nichi.co/buzz-tongue-prefer" style="zoom:40%;" /> 



# 面向对象（基础部分）

## 类与对象

### 区别和联系

1. 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型. 
2. 对象是具体的，实际的，代表一个具体事物, 即是实例
3. 类是对象的模板，对象是类的一个个体，对应一个实例 

### 对象在内存中的形式

<img src="https://pb.nichi.co/mesh-virus-blind" style="zoom: 28%;" /> 

### 属性/成员变量/字段

1. 从概念或叫法上看： 成员变量 = 属性 = field(字段) （即 成员变量是用来表示属性的）
2. 属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)

### 注意事项和细节说明

1. 属性的定义语法同变量，示例：访问修饰符 属性类型 属性名; 

2. 属性的定义类型可以为任意类型，包含基本类型或引用类型 

3. 属性如果不赋值，有默认值，规则和数组一致。

   具体说: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000， boolean false，String null

### 如何创建对象

1. 先声明再创建 

   Cat cat ; //声明对象 cat 

   cat = new Cat(); //创建 

2. 直接创建 

3. Cat cat = new Cat();

### 如何访问属性

基本语法 

对象名.属性名;

### 类和对象的内存分配机制

我们定义一个人类(Person)(包括 名字,年龄)

```java
Person p1=new Person(); 
p1.age=10;
p1.name="小明";
Person p2=p1;//把p1赋给了 p2，让p2指向p1 
System.out.println(p2.age);
```

请问:p2.age究竟是多少? 并画出内存图:

 <img src="https://pb.nichi.co/case-isolate-major" style="zoom:40%;" />

- Java 内存的结构分析 
  1. 栈： 一般存放基本数据类型(局部变量) 
  2. 堆： 存放对象(Cat cat , 数组等) 
  3. 方法区：常量池(常量，比如字符串)，类加载信息

- Java 创建对象的流程简单分析
  1. 先加载 Person 类信息(属性和方法信息, 只会加载一次) 
  2. 在堆中分配空间, 进行默认初始化(看规则) 
  3. 把地址赋给 p , p 就指向对象
  4. 进行指定初始化， 比如 p.name =”jack” p.age = 10



## 成员方法

### 方法的调用机制原理

<img src="https://pb.nichi.co/horn-cupboard-prison" style="zoom: 30%;" /> 

### 成员方法的好处

1. 提高代码的复用性
2. 可以将实现的细节封装起来，然后供其他用户来调用即可

### 成员方法的定义

```java
访问修饰符 返回数据类型 方法名（形参列表..） {//方法体 
    语句； 
    return 返回值; 
}
```

1. 形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)
2. 返回数据类型：表示成员方法输出, void 表示没有返回值 
3. 方法主体：表示为了实现某一功能代码块 
4. return 语句不是必须的

### 注意事项和使用细节 

- 访问修饰符 (作用是控制 方法使用的范围) 

  如果不写默认访问，[有四种: public, protected, 默认, private]

- 返回数据类型 

  1. 一个方法最多有一个返回值 [返回多个结果时使用  返回数组 ] 
  2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 
  3. 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和return 的 值类型一致或兼容 
  4. 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;

- 方法名 

  遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如 得到两个数的和 getSum, 开发中按照规范

- 形参列表
  1. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如 getSum(int n1,int n2)

  2. 参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(int[][] map)

  3. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数！

  4. 方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致！

- 方法体

  里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即：方法不能嵌套定义

- 方法调用细节说明

  1. 同一个类中的方法调用：直接调用即可。比如 方法名(参数);
  2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如 对象名.方法名(参数);
  3. 跨类的方法调用和方法的访问修饰符相关



## 成员方法传参机制

### 基本数据类型的传参机制 

基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！

### 引用数据类型的传参机制

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！



## 方法递归调用

### 基本介绍

递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变得简洁

### 递归举例

1. 打印问题
2. 阶乘问题

### 递归重要规则

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的，不会相互影响，比如n变量
3. 如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError，死龟了
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕



## 方法重载

### 基本介绍

java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！

### 重载的好处

1. 减轻了起名的麻烦
2. 减轻了记名的麻烦

### 注意事项和使用细节

1. 方法名：必须相同
2. 形参列表：必须不同（形参类型或个数或顺序至少有一样不同，参数名无要求）
3. 返回类型：无要求

## 可变参数

### 基本概念

java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法，就可以通过可变参数实现 

### 基本语法

```java
访问修饰符 返回类型 方法名(数据类型... 形参名){
    
}
```

### 注意事项和使用细节

1. 可变参数的实参可以为0个或任意多个
2. 可变参数的实参可以为数组
3. 可变参数的本质就是数组
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须放在最后
5. 一个形参列表中只能出现一个可变参数



## 作用域

### 基本使用

1. 在java编程中，主要的变量就是属性（成员变量）和局部变量

2. 我们说的局部变量一般是指在成员方法中定义的变量

3. java作用域的分类

   全局变量：也就是属性，作用域为整个类体

   局部变量：也就是除属性之外的其他变量，作用域为定义它的代码块中

4. 全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值

### 注意事项和使用细节

1. 属性和局部变量可以重名，访问时遵循就近原则

2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名

3. 属性生命周期长，伴随对象的创建而创建，伴随着对象销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。

4. 作用域范围不同

   全局变量/属性：可以被类使用，或其他类使用（通过对象调用）

   局部变量：只能在本类对应的方法中使用

5. 修饰符不同

   全局变量/属性可以加修饰符

   局部变量不可以加修饰符



## 构造方法/构造器

### 基本语法

```jav
[修饰符] 方法名(形参列表){
	方法体；
}
```

1. 构造器的修饰符可以默认， 也可以是 public protected private
2. 构造器没有返回值
3. 方法名和类名字必须一样
4. 参数列表和成员方法一样的规则
5. 构造器的调用, 由系统完成

### 基本介绍

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有几个特点： 

1. 方法名和类名相同
2. 没有返回值
3. 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

### 注意事项和使用细节

1. 一类可以定义多个不同的构造器，即重载构造器
2. 构造器名和类名要相同
3. 构造器没有返回值
4. 构造器是完成对象的初始化，并不是创建对象
5. 在创建对象时，系统自动的调用该类的构造方法
6. 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器）
7. 一旦定义了自己的构造器，默认的构造就覆盖了，就不能再使用默认的无参构造器，除
8. 非显示的定义一下



## this关键字

> Java虚拟机会给每个对象分配this，代表当前对象

### 深入理解this

<img src="https://pb.nichi.co/rare-beach-ivory" style="zoom: 33%;" /> 

this小结：简单地说，哪个对象调用，this就代表哪个对象

### 注意事项和使用细节

1. this 关键字可以用来访问本类的属性、方法、构造器
2. this 用于区分当前类的属性和局部变量
3. 访问成员方法的语法：this.方法名(参数列表);
4. 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一条语句)
5. this不能在类定义的外部使用，只能在类定义的方法中使用。

# 面向对象（中级部分）

## IDEA

1) 删除当前行, 默认是 ctrl + Y  
2) 复制当前行, 自己配置 ctrl + D 
3) 补全代码 alt + / 
4) 添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】
5) 导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可 
6) 快速格式化代码 ctrl + alt + L 
7) 快速运行程序 自己定义 alt + R 
8) 生成构造器等 alt + insert [提高开发效率] 
9) 查看一个类的层级关系 ctrl + H [学习继承后，非常有用] 
10) 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] 
11) 自动的分配变量名 , 通过 在后面加 .var
12) Ctrl+Alt+T 异常处理
13) 显示所有的快捷键的的快捷键 ctrl + j
14) alt + Insert 可以快速生成 构造器、Getter和Setter方法、重写equals() 和 hashCod() 或 toString() 方法等
15) Cltr + Alt + M快捷把代码块包装成方法



## 包

### 作用

1. 区分相同名字的类
2. 当类很多时，可以很好的管理
3. 控制访问范围

### 包的基本语法

package com.xiaochen;

- 说明：
  1. package关键字，表示打包
  2. com.xiaochen:表示包名

### 包的本质

包的本质 实际上就是创建不同的文件夹/目录来保存类文件

### 常用的包

1. java.lang.* 

   //lang 包是基本包，默认引入，不需要再引入

2. java.util.* 

   //util 包，系统提供的工具包, 工具类，使用 Scanner 

3. java.net.* 

   //网络包，网络开发 

4. java.awt.* 

   //是做 java 的界面开发，GUI

### 如何引入包

- 语法

  import 包;

- 我们引入一个包的主要目的是要使用该包下的类

  比如`import java.util.Scanner;`就只是引入一个类Scanner

  `import java.util.*;`表示将java.util包所有都引入

### 注意事项和使用细节

1. package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一个package
2. import指令 位置放在package的下面，在类定义的前面，可以有多句且没有顺序要求



## 访问修饰符

### 基本介绍

> java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）

1. 公开级别:用 public 修饰,对外公开 
2. 受保护级别:用 protected 修饰,对子类和同一个包中的类公开
3. 默认级别:没有修饰符号,向同一个包的类公开
4. 私有级别:用 private 修饰,只有类本身可以访问,不对外公开

### 四种访问修饰符的访问范围

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| :------: | :------------: | :--: | :--: | :--: | :----: |
|   公开   |     public     |  √   |  √   |  √   |   √    |
|  受保护  |   protected    |  √   |  √   |  √   |   ×    |
|   默认   |   没有修饰符   |  √   |  √   |  ×   |   ×    |
|   私有   |    private     |  √   |  ×   |  ×   |   ×    |

### 使用的注意事项

1. 修饰符可以用来修饰类中的属性，成员方法以及类
2. 只有默认的和public才能修饰类!，并且遵循上述访问权限的特点
3. 成员方法的访问规则和属性完全一样.

### 封装

> 封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]，才能对数据进行操作

### 封装的理解和好处

1. 可以实现隐藏细节：方法(链接数据库) <-- 调用(传入参数...)
2. 可以对数据进行验证，保证安全合理

### 封装的实现步骤

1. 将属性进行私有化private（不能直接修改属性）

2. 提供一个共公的(public)set方法，用于对属性判断并赋值

   ```java
   public void setXxx(类型 参数名){//Xxx表示某个属性
       //加入对数据验证的业务逻辑
       属性 = 参数名;
   }
   ```

3. 提供一个共公的(public)get方法，用于获取属性的值

   ```java
   public 数据类型 getXxx(){//权限判断，Xxx某个属性
       return Xxx;
   }
   ```

### 将构造器和 setXxx 结合

```java
//有三个属性的构造器 
public Person(String name, int age, double salary) { 
    // this.name = name; 
    // this.age = age; 
    // this.salary = salary; 
    //我们可以将 set 方法写在构造器中，这样仍然可以验证 
    setName(name); 
    setAge(age); 
    setSalary(salary); 
}
```



## 继承

> 继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可

<img src="https://pb.nichi.co/click-make-liberty" style="zoom: 40%;" /> 

### 继承的基本语法

`class 之类 extends 父类{}`

1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫超类，基类
3. 子类又叫派生类 

### 继承给编程带来的便利

1. 代码的复用性提高了
2. 代码的拓展性和维护性提高了

### 使用细节和注意事项

1. 子类继承了所有的属性和方法，但是私有属性不能在子类直接访问，要通过公有的方法去访问

2. 子类必须调用父类的构造器，完成父类初始化

3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类哪个构造器去完成对父类的初始化工作，否则，编译不通过

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)

5. super在使用时，必须放在构造器的第一行(super只能在构造器中使用)

6. super() 和 this() 都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中

7. Java所有类都是object类的子类

8. 父类构造器的调用不限于直接父类，将一直往上追溯直到object类(顶级父类)

9. 子类最多只能继承一个父类(指直接继承)，即Java中是单继承机制

   思考：如何让A类继承B类和C类？ 【A继承B，B继承C】

10. 不能滥用继承，子类和父类必须满足 is-a 的逻辑关系

### 继承的本质

当子类对象创建好后，建立查找关系

<img src="https://pb.nichi.co/project-useless-eyebrow" style="zoom: 40%;" />



## super关键字

> super代表父类的引用用于访问父类的属性、方法、构造器

### 基本语法

1. 访问父类的属性，但不能访问父类的private属性

   super.属性名;

2. 访问父类的方法，不能访问父类的private方法

   super.方法名(参数列表);

3. 访问父类的构造器，只能放在构造器的第一句且只能出现一句

   super(参数列表);

### super给编程带来的便利和使用细节

1. 调用父类构造器的好处

   分工明确，父类属性由父类初始化，子类的属性又子类初始化

2. 当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果

3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则

### super和this的比较

| 区别点     | this                                                   | super                                    |
| ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 从父类开始查找属性                       |
| 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类据需查找   | 从父类开始查找方法                       |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，必须放在子类构造器的首行 |
| 特殊       | 表示当前对象                                           | 子类中访问父类对象                       |



## 方法重写/覆盖

### 基本介绍

简单的说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法

### 注意事项和使用细节

1. 子类的方法的**形参列表，方法名称**要和父类方法的**形参列表，方法名称**完全一样

2. 子类方法的返回类型和父类方法的返回类型一样，或者是父类返回类型的子类

   比如 父类返回类型是Object，子类方法返回类型是String

   `public Object getInfo(){}` `public String getInfo(){}`

3. 子类方法不能缩小父类方法的访问权限

   public > protected > 默认 > private

   `void sayOk(){}` `public void sayOk(){}`

### 重写和重载的比较

| 名称           | 发生范围 | 方法名   | 形参列表                         | 返回类型                                           | 修饰符                             |
| -------------- | -------- | -------- | -------------------------------- | -------------------------------------------------- | ---------------------------------- |
| 重载(overload) | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同 | 无要求                                             | 无要求                             |
| 重写(override) | 父子类   | 必须一样 | 相同                             | 子类重写的方法，返回的类型和父类一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |



## 多态

> 方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的

### 多态的具体提现

#### 方法的多态

重写和重载就体现多态

#### 对象的多态

1. 一个对象的编译类型和运行类型可以不一致
2. 编译类型在定义对象时，就确定了，不能改变
3. 运行类型是可以变化的
4. 编译类型看定义时 =号 的左边，运行类型看 =号 的右边（编译看左边，运行看右边）

### 注意事项和细节讨论

- 多态的**前提**是：两个对象(类)存在继承关系

- 多态的向上转型

  1. 本质：父类的引用指向了子类的对象

  2. 语法：`父类类型 引用名 = new 子类类型();`

  3. 特点：

     编译类型看左边，运行类型看右边

     可以调用父类中的所有成员（需遵守访问权限）

     不能调用子类中特有的成员

     最终运行效果看子类的具体实现

- 多态的向下转型

  1. 语法：`子类类型 引用名 = (子类类型)父类引用`
  2. 只能强转父类的引用，不能强转父类的对象
  3. 要求父类的引用必须指向的是当前目标类型的对象
  4. 当向下转型后，可以调用子类类型中所有的成员

- 多态的弊端

  我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时多态的写法就无法访问子类独有功能了

### instanceof

基本语法：`变量名 instanceof 数据类型`
如果变量属于该数据类型或者其子类类型，返回true。
如果变量不属于该数据类型或者其子类类型，返回false。

```java
public class Test {
    public static void main(String[] args) {
        // 向上转型  
        Animal a = new Cat();  
        a.eat();               // 调用的是 Cat 的 eat

        // 向下转型  
        if (a instanceof Cat){
            Cat c = (Cat)a;       
            c.catchMouse();        // 调用的是 Cat 的 catchMouse
        } else if (a instanceof Dog){
            Dog d = (Dog)a;       
            d.watchHouse();       // 调用的是 Dog 的 watchHouse
        }
    }  
}
```

### Java的动态绑定机制

1. 当调用对象方法的时候，**该方法会和该对象**的**内存地址/运行类型**绑定
2. 当调用对象**属性**时，**没有动态绑定机制**，哪里声明，哪里使用

### 多态的应用

1. 多态数组

   数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

2. 多态参数



## Object类详解

### equals方法

#### ==和equals的对比

1. ==是一个比较运算符
2. ==既可以判断基本类型，又可以判断引用类型
3. ==如果判断基本类型，判断的是值是否相等
4. ==如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象
5. equals是Object类中的方法，只能判断引用类型
6. equals默认判断的是地址是否相等，子类中往往重写该方法，用于判断是否相等

#### 重写 equals 方法

[EqualsExercise01.java · 小陈/Java Study Notes - Gitee.com](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/EqualsExercise01.java)

```java
public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj instanceof Person) {
            Person p = (Person) obj;
            return this.name == p.name && this.age == p.age && this.gender == p.gender;
        }
        return false;
}
```



### hashCode方法

1. 提高具有哈希结构的容器的效率
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
3. 两个引用，如果指向的是不同对象，则哈希值是不一样的
4. 哈希值主要根据地址号来的，不能完全将哈希值等价于地址

### toString 方法

默认返回：全类名+@+哈希值的十六进制

子类往往重写 toString 方法，用于返回对象的属性信息

重写 toString 方法，打印对象或拼接对象时，都会**自动调用**该对象的**toString** 形式

当**直接输出一个对象**时，**toString方法会被默认的调用**, 比如`System.out.println(monster)；` 就会默认调用monster.toString()

### finalize 方法

1. 当对象被回收时，系统自动调用该对象的 finalize 方法，子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法
3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制



## 断点调试(debug)

### 基本介绍

1. 断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug
2. 断点调试是程序员必须掌握的技能
3. 断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平

### 快捷键

- F7 (跳入)
- F8 (跳过)
- shift+F8 (跳出)
- F9 (resume,执行到下一个断点)
- F7 (跳入方法内)
- F8 (逐行执行代码)
- shift+F8 (跳出方法)



# 面向对象（高级部分）

## 类变量和类方法

### 类变量

> 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量

#### 定义类变量

`访问修饰符 static 数据类型 变量名;` [推荐]

`static 访问修饰符 数据类型 变量名;`

#### 访问类变量

`类名.变量名` [推荐]

`对象名.变量名`

静态变量的**访问修饰符的访问权限和范围**是和普通属性的**一样**的

#### 注意事项和细节讨论

1. 什么时候需要用类变量

   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）

2. 类变量与实例变量（普通属性）区别

   类变量是该类的所有对象共享的，而实例变量是每个对象独享的

3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

4. 类变量可以通过`类名.类变量名`或者`对象名.类变量名`来访问，但iava设计者推荐我们使用`类名.类变量名`方式访问【前提是 满足访问修饰符的访问权限和范围】

5. 实例变量不能通过`类名.类变量名` 方式访问

6. 类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了就可以使用类变量了

7. 类变量的生命周期是随类的加载开始，随着类消亡而销毁

### 类方法

#### 基本介绍

> 类方法也叫静态方法

`访问修饰符 static 数据返回类型 方法名(){}` [推荐]

`static 访问修饰符 数据返回类型 方法名(){}`

#### 类方法的调用

`类名.类方法名(参数);`

`对象名.类方法名(参数);`

#### 使用场景

当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率

#### 注意事项和细节讨论

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：
    类方法中无this的参数
    普通方法中隐含着this的参数

2. 类方法可以通过类名调用，也可以通过对象名调用

3. 普通方法和对象有关，需要通过对象名调用，比如`对象名.方法名(参数)`，不能通过类名调用

4) 类方法中不允许使用和对象有关的关键字，比如this和super，普通方法（成员方法）可以

5) 类方法（静态方法）中只能访问静态变量或静态方法

6) 普通成员方法，既可以访问非静态成员，也可以访问静态成员

- 小结：**静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员**（必须遵守访问权限）



## 深入理解main方法

**解释main方法的形式：**`public static void main(String[] args){}`

1. main方法时虚拟机调用
2. Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public
3. Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
4. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数 `java 运行的类名 参数1 参数2 参数3`

**特别提示：**

1. 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性
2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员



## 代码块

### 基本介绍

代码块又称为初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不通过对象或类显式调用，而是加载类时，或创建对象时隐式调用

### 基本语法

```java
[修饰符]{
    代码;
};
```

注意说明：

1. 修饰符可选，只能为static

2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块
3. 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
4. ;可以写上，也可省略

### 代码块的好处

1. 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
2. 场景：如果多个构造器中都有重复语句，可以抽取到初始化块，提高代码复用性

### 注意事项和细节讨论

1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着**类的加载**而执行，并且**只会执行一次**。如果是普通代码块， 每创建一个对象，就执行一次。

2. 类什么时候被加载

   1. 创建对象实例时(new)

   2. 创建子类对象实例，父类也会被加载

   3. 使用类的静态成员时（静态属性，静态方法）


3. 普通的代码块，在创建对象实例时，会被隐式的调用
   被创建一次，就会调用一次
   如果只是使用类的静态成员时，普通代码块并不会执行

   *小结:*
   *1.static代码块是类加载时，执行，只会执行一次*
   *2.普通代码块是在创建对象时调用的，创建一次，调用一次*

4. 创建一个对象时，在一个类调用顺序是：

   1. 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按定义顺序调用）
   2. 调用普通代码块和普通属性初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
   3. 调用构造方法

5. 构造器的最前面其实隐含了super()和调用普通代码块

   静态相关的代码块，属性初始化，在类加载时，就执行完毕因此是优先于构造器和普通代码块执行的

   ```java
   class A{
       public A(){//构造器
           //构造器里有隐藏的执行要求
           //(1)super();
           //(2)调用普通代码块
           System.out.println("ok");//最后执行构造器
       }
   }
   ```

6. 创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：[案例演示直达链接](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/CodeBlockDetail04.java)

   1. 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   2. 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   3. 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   4. 父类的构造器方法
   5. 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   6. 子类的构造器方法

7. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员



## 单列设计模式

### 设计模式

1. 静态方法和静态属性的经典使用
2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索

### 单列模式

1. 所谓类的单列设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
2. 单列模式有两种方式：① 饿汉式 ② 懒汉式

### 应用实例

- 饿汉式和懒汉式单列模式实现步骤如下：

1. 构造器私有化 => 防止直接new
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法

- 饿汉式：

```java
public class SingleTon01 {
    public static void main(String[] args) {
    	//通过getInstance()方法可以获取对象
        GirlFriend instance = GirlFriend.getInstance();
        System.out.println(instance);
    }
}
//有一个类， GirlFriend
//只能有一个女朋友
class GirlFiend{
    private String name;
    //为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static
    //对象，通常是重量级的对象, 饿汉式可能造成创建了对象，但是没有使用
    private static GirlFriend gf = new GirlFriend("小红红");
    //如何保障我们只能创建一个 GirlFriend 对象
    //步骤[单例模式-饿汉式]
    //1. 将构造器私有化
    //2. 在类的内部直接创建对象(该对象是 static)
    //3. 提供一个公共的 static 方法，返回 gf 对象
    private GirlFriend(String name) {
        this.name = name;
    }
    public static GirlFriend getInstance() {
        return gf;
    }
}
```

- 懒汉式：

```java
public class SingleTon02 { 
    public static void main(String[] args) { 
        Cat instance = Cat.getInstance(); //通过getInstance()方法可以获取对象
        System.out.println(instance);
    }
}
//希望在程序运行过程中，只能创建一个Cat对象
class Cat{
    private String name;
    private static Cat cat ; //默认是null
    //步骤
    //1.仍然构造器私有化
    //2.定义一个 static 静态属性对象
    //3.提供一个 public 的 static 方法，可以返回一个 Cat 对象
    //4.懒汉式，只有当用户使用 getInstance 时，才返回 cat 对象, 后面再次调用时，会返回上次创建的 cat 对象从而保证了单例
    private Cat(String name) { 
        this.name = name; 
    }
    public static Cat getInstance() { 
        if(cat == null) {//如果还没有创建 cat 对象 
            cat = new Cat("小可爱"); 
        }
        return cat; 
    }
}
```

### 比较

1. 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题
3. 饿汉式存在资源浪费的可能。如果因为程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题



## final关键字

### 基本介绍

- final中文意思：最后的，最终的
- final可以修饰类、属性、方法和局部变量
- 在某些情况下，程序员可能有以下需求就会用到final：
  1. 当不希望类被继承时，可以用final修饰`final class 类名{}`
  2. 当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰`访问修饰符 final 返回类型 方法名(){}`
  3. 当不希望类的某个属性的值被修改，可以用final修饰`public final double TAX_RATE=0.08;`
  4. 当不希望某个局部变量被修改，可以用final修饰`final double TAX_RATE=0.08;`

### 注意事项和细节讨论

1. final修饰的属性又叫常量，一般用XX_XX_XX来命名
2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以加在如下位置之一：
   1. 定义时：如`public final double TAX_RATE=0.08;`
   2. 在构造器中
   3. 在代码块中
3. 如果final修饰的属性是静态的，则初始化的位置只能是
   1. 定义时
   2. 在静态代码块中（不能在构造器中赋值）
4. final类不能被继承，但是可以实例化对象
5. 如果类不是final类，但是含有final方法，则该方法虽然不能被重写，但是可以被继承（即仍然遵守继承规则）
6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法
7. final不能修饰构造方法（即构造器）
8. **final和static**往往**搭配使用**，效率更高，**不会导致类加载**，底层编译器做客优化处理
9. 包装类（Integer，Double，Float，Boolean，String等）都是final类，不能被继承



## 抽象类

> 当父类的一些方法不能被确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类

### 基本介绍

1. 用abstract关键字来修饰一个类时，这个类就叫抽象类

   `访问修饰符 abstract 类名{}`

2. 用abstract关键字来修饰一个方法时，这个方法就是抽象方法

   `访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体`

3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类

4. 抽象类在框架和设计模式使用较多

### 注意事项和细节讨论

1. 抽象类不能被实例化
2. 抽象类不一定要包含abstract方法（抽象类可以没有abstract方法）
3. 一旦包含了abstract方法，则这个类必须声明为abstract
4. abstract只能修饰类和方法，不能修饰属性和其他的
5. 抽象类可以有任意成员（**抽象类本质还是类**），比如：非抽象方法、构造器、静态属性等
6. 抽象方法不能有主体，即不能实现
7. 如果一个类继承了抽象类，则必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类
8. 抽象方法**不能**使用**private、final和static**来修饰，因为这些关键字都是和重写相违背的



## 模板设计模式

### 基本介绍

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式

### 可以解决的问题

1. 当功能内部一部分实现是确定，一部分实现是不确定的，这时可以把不确定的部分暴露出去，让子类去实现
2. 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式

### 最佳实践

需求：

1. 有多个类，完成不同的任务job

2. 要求统计得到各自完成任务的时间

   ```java
   public class TestTemplate {
       public static void main(String[] args) {
           AA aa = new AA();
           aa.calculateTime();
           BB bb = new BB();
           bb.calculateTime();
       }
   }
   abstract class Template {//抽象类-模板设计模式
       public abstract void job();//抽象方法
       public void calculateTime() {//实现方法，调用 job 方法
           //得到开始的时间
           long start = System.currentTimeMillis();
           job(); //动态绑定机制
           //得的结束的时间
           long end = System.currentTimeMillis();
           System.out.println("任务执行时间 " + (end - start));
       } 
   }
   class AA extends Template {//子类继承抽象类Template
       @Override
       public void job(){//实现 Template 的抽象方法 job
           long num = 0;
           for (long i = 1; i <= 800000; i++) {
               num += i;
           }
       }
   }
   class BB extends Template {//子类继承抽象类Template
       @Override
       public void job() {//这里也重写了 Template 的 job 方法
           long num = 0;
           for (long i = 1; i <= 80000; i++) {
               num *= i;
           }
       }
   }
   ```



## 接口

### 基本介绍

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法：

```java
interface 接口名{
    //属性
    //抽象方法
}
```

```java
class 类名 implements 接口{
    自己属性;
    自己方法;
    必须实现的接口的抽象方法
}
```

小结：接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体（jdk7.0），接口体现了程序设计的多态和高内聚低耦合的设计思想

特别说明：jdk8.0后接口类可以有静态方法，默认方法，也就是说接口可以有方法的具体实现

### 注意事项和细节讨论

1. 接口不能被实例化

2. 接口中的所有方法是public方法，接口中的抽象方法，可以不用abstract修饰

   `void aaa();`实际上是`abstract void aaa();`

3. 一个普通类实现接口，就必须将该接口的所有方法都实现（可以使用Alt + Enter来解决）

4. 抽象类实现接口，可以不用实现接口的方法

5. 一个类同时可以实现多个接口

6. 接口中的属性，只能是final的，而且是public static final 修饰的

   比如：`int a = 1;`实际上是`public static final int a = 1;`

7. 接口中属性的访问形式：`接口名.属性名`

8. 接口中不能继承其他的类，但是可以继承多个别的接口 `interface A extends B,C{}`

   注意：类与接口是实现关系；接口与接口是继承关系

   接口继承接口就是把其他接口的抽象方法与本接口进行了合并

9. 接口的修饰符只能是public和默认，这点和类的修饰符一样

### 实现接口和继承类

- 接口和继承解决的问题不同
  - 继承的主要价值在于：解决代码的**复用性和可维护性**
  - 接口的价值主要在于：**设计**，设计好各种规范（方法），让其他类去实现这些方法，即更加的灵活
- 接口比继承更加**灵活**
  - 接口比继承更加灵活，继承是满足 is - a 的关系，而接口只需满足 like - a 的关系
- 接口在一定程度上实现代码解耦[即：接口规范性+动态绑定机制]

- 继承小结:
  - 当子类继承了父类，就自动的拥有父类的功能如果子类需要扩展功能，可以通过实现接口的方式扩展可以理解实现接口是对 java 单继承机制的一种补充

### 接口的多态特性

1. 多态参数：[代码演示](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/InterfacePolyParameter.java)
2. 多态数组：[代码演示](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/InterfacePolyArr.java)
3. 接口存在多态传递现象：[代码演示](https://gitee.com/gitee-xiaochen/java-study-notes/blob/master/InterfacePolyPass.java)



## 内部类

> 将一个类A定义在另一个类B里面，里面的那个类A就称为**内部类**，B则称为**外部类**。可以把内部类理解成寄生，外部类理解成宿主

### 基本介绍

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)，是我们类的第五大成员，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系

```java
//基本语法
class Outer{//外部类
    class Inner{//内部类
    }
}
class Other{//外部其他类
}
```

### 内部类的分类

定义在外部类局部位置上 （比如方法内）：

1. 局部内部类（有类名）

2. 名内部类（没有类名）

定义在外部类的成员位置上:

1. 成员内部类（没用static修饰）
2. 静态内部类（使用static修饰）

### 局部内部类的使用

> 局部内部类是定义在外部类的局部位置，比如方法中，并且有类名

**基本语法：**

```java
class 外部类名 {
	数据类型 变量名;
	修饰符 返回值类型 方法名(参数列表) {
		class 内部类 {
			// 成员变量
			// 成员方法
		}
	}
}
```

1. 可以直接访问外部类的所有成员，包含私有的

2. 不能添加访问修饰符，因为它的地位就是一个局部变量，局部变量是不能使用修饰符的，但是可以使用final 修饰，因为局部变量也可以使用final

3. 作用域：仅仅在定义它的方法或代码块中

4. 局部内部类---访问---->外部类的成员

   访问方式：直接访问

5. 外部类---访问---->局部内部类的成员

   访问方式:创建对象，再访问（注意：必须在作用域内）

6. 外部其他类---不能访问---->局部内部类（因为局部内部类地位是一个局部变量）

7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问

### 匿名内部类的使用

> 匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名

**基本语法：**

```java
new 类或接口(参数列表){
    重写方法;
};
```

1. 匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，因此可以调用匿名内部类方法

2. 可以自己访问外部类的所有成员，包含私有的

3. 不能添加访问修饰符，因为它的地位就是一个局部变量

4. 作用域：仅仅在定义它的方法或代码块中

5. 匿名内部类---访问---->外部成员

   访问方式：直接访问

6. 外部其他类---不能访问---->匿名内部类（因为匿名局部内部类地位是一个局部变量）

7. 如果外部类和匿名内部类重名时，匿名内部类访问的话，默认遵循就近原则，如果想访问外部的成员，则可以使用`外部类名.this.成员`去访问

**使用方式：**

```java
interface Swim {
    public abstract void swimming();
}

public class Demo07 {
    public static void main(String[] args) {
        // 使用匿名内部类
		new Swim() {
			@Override
			public void swimming() {
				System.out.println("自由泳...");
			}
		}.swimming();

        // 接口 变量 = new 实现类(); // 多态,走子类的重写方法
        Swim s2 = new Swim() {
            @Override
            public void swimming() {
                System.out.println("蛙泳...");
            }
        };

        s2.swimming();
        s2.swimming();
    }
}
```

**特点：**

1. 定义一个没有名字的内部类
2. 这个类实现了父类，或者父类接口
3. 匿名内部类会创建这个没有名字的类的对象

**使用场景：**

```java
interface Swim {
    public abstract void swimming();
}

public class Demo07 {
    public static void main(String[] args) {
        // 普通方式传入对象
        // 创建实现类对象
        Student s = new Student();
        
        goSwimming(s);
        // 匿名内部类使用场景:作为方法参数传递
        Swim s3 = new Swim() {
            @Override
            public void swimming() {
                System.out.println("蝶泳...");
            }
        };
        // 传入匿名内部类
        goSwimming(s3);

        // 完美方案: 一步到位
        goSwimming(new Swim() {
            public void swimming() {
                System.out.println("大学生, 蛙泳...");
            }
        });

        goSwimming(new Swim() {
            public void swimming() {
                System.out.println("小学生, 自由泳...");
            }
        });
    }

    // 定义一个方法,模拟请一些人去游泳
    public static void goSwimming(Swim s) {
        s.swimming();
    }
}
```

### 成员内部类的使用

> 成员内部类定义在内部类的成员位置，并且没有static修饰

1. 可以直接访问外部类的所有成员，包括私有的

2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员

3. 作用域和外部类其他成员一样，为整个类体

4. 成员内部类---访问---->外部类成员（比如：属性）

   访问方式：直接访问

5. 外部类---访问---->成员内部类

   访问方式：创建对象，再访问

6. 外部其他类---访问---->成员内部类

   访问方式：`外部类.内部类 变量 = new 外部类().new 内部类();`

   ```java
   public class Test {
       public static void main(String[] args) {
           //宿主：外部类对象。
           // Outer out = new Outer();
           // 创建内部类对象。
           Outer.Inner oi = new Outer().new Inner();//方式一
           oi.method();
           Outer.Inner oi2 = Outer.getInstance();//方式二
           oi2.method();
       }
   }
   class Outer {
       // 成员内部类，属于外部类对象的。
       // 拓展：成员内部类不能定义静态成员。
       public class Inner{
           // 这里面的东西与类是完全一样的。
           public void method(){
               System.out.println("内部类中的方法被调用了");
           }
       }
       public static Inner getInstance(){//创建一个返回成员内部类的方法
           return new Inner();
       }
   }
   ```

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用`外部类名.this.成员`去访问

   ```java
   class Outer {	// 外部类
       private int a = 30;
       // 在成员位置定义一个类
       class inner {
           private int a = 20;
           public void method() {
               int a = 10;
               System.out.println(???);	// 10   答案：a
               System.out.println(???);	// 20	答案：this.a
               System.out.println(???);	// 30	答案：Outer.this.a
           }
       }
   }
   ```

### 静态内部类的使用

> 静态内部类是定义在外部类的成员位置，并且有static修饰

1. 可以直接访问外部类的所有成员，包括私有的，但**不能直接访问非静态成员**

2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员

3. 作用域和外部类其他成员一样，为整个类体

4. 静态内部类---访问---->外部类成员（比如：静态属性）

   访问方式：直接访问所有静态成员

5. 外部类---访问---->静态内部类

   访问方式：创建对象，再访问

6. 外部其他类---访问---->静态内部类

   访问方式：`外部类名.内部类名.方法名();`

7. 如果外部类和内部类的成员重名时，静态内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用`外部类名.成员`去访问

8. 实例演示：

   ```java
   class Outer01{// 外部类：Outer01
       private static String sc_name = "jack";
       public static class Inner01{// 内部类: Inner01
           // 这里面的东西与类是完全一样的
           private String name;
           public Inner01(String name) {// 构造器
               this.name = name;
           }
           public void showName(){
               System.out.println(this.name);
               // 拓展:静态内部类可以直接访问外部类的静态成员。
               System.out.println(sc_name);
           }
       }
   }
   
   public class InnerClassDemo01 {
       public static void main(String[] args) {
           // 创建静态内部类对象
           // 外部类.内部类  变量 = new  外部类.内部类构造器;
           Outer01.Inner01 in  = new Outer01.Inner01("张三");
           in.showName();
       }
   }
   ```
